--:h lua 642
-- TODO: work with notify

-- vim.notify = require("notify")
-- local plugin = "My Awesome Plugin"
-- vim.notify("This is an error message.\nSomething went wrong!", "error", {
-- 	title = plugin,
-- 	on_open = function()
-- 		vim.notify("Attempting recovery.", vim.log.levels.WARN, {
-- 			title = plugin,
-- 		})
-- 		local timer = vim.loop.new_timer()
-- 		timer:start(2000, 0, function()
-- 			vim.notify({ "Fixing problem.", "Please wait..." }, "info", {
-- 				title = plugin,
-- 				timeout = 3000,
-- 				on_close = function()
-- 					vim.notify("Problem solved", nil, { title = plugin })
-- 					vim.notify("Error code 0x0395AF", 1, { title = plugin })
-- 				end,
-- 			})
-- 		end)
-- 	end,
-- })

-- local async = require("plenary.async")
-- local notify = require("notify").async
--
-- async.run(function()
--   notify("Let's wait for this to close").events.close()
--   notify("It closed!")
-- end)

-- local vim = vim
-- -- Trying to understand the User autocmd's
-- local aug = vim.api.nvim_create_augroup("clear the This_is_user_autocmd", { clear = true })
-- vim.api.nvim_create_autocmd("InsertEnter", {
-- 	group = aug,
-- 	-- pattern = "This_is_user_autocmd",
-- 	callback = function()
-- 		print("this is right")
-- 	end,
-- })

-- vim.api.nvim_create_autocmd("InsertEnter", {
-- 	group = vim.api.nvim_create_augroup("you are right", { clear = true }),
-- 	pattern = "clear the This_is_user_autocmd",
-- 	callback = function()
-- 		vim.cmd("do This_is_user_autocmd")
-- 	end,

-- local notify = require("notify")
-- local async = require("plenary.async")
-- async.run(function()
-- 	notify("Let's wait for this to close").events.close()
-- 	notify("It closed!")
-- end)

----------------------------------------------------------------------
--                      What is going on here                       --
----------------------------------------------------------------------

-- local augroup = vim.api.nvim_create_augroup
-- local autocmd = vim.api.nvim_create_autocmd
--
-- if _G.StatusColumn then
-- 	return
-- end
--
-- _G.StatusColumn = {
-- 	handler = {
-- 		fold = function()
-- 			local lnum = vim.fn.getmousepos().line
--
-- 			-- Only lines with a mark should be clickable
-- 			if vim.fn.foldlevel(lnum) <= vim.fn.foldlevel(lnum - 1) then
-- 				return
-- 			end
--
-- 			local state
-- 			if vim.fn.foldclosed(lnum) == -1 then
-- 				state = "close"
-- 			else
-- 				state = "open"
-- 			end
--
-- 			vim.cmd.execute("'" .. lnum .. "fold" .. state .. "'")
-- 		end,
-- 	},
-- 	display = {
-- 		fold = function()
-- 			local lnum = vim.v.lnum
-- 			local icon = "  "
--
-- 			-- Line isn't in folding range
-- 			if vim.fn.foldlevel(lnum) <= 0 then
-- 				return icon
-- 			end
--
-- 			-- Not the first line of folding range
-- 			if vim.fn.foldlevel(lnum) <= vim.fn.foldlevel(lnum - 1) then
-- 				return icon
-- 			end
--
-- 			if vim.fn.foldclosed(lnum) == -1 then
-- 				icon = Icons.misc.expanded
-- 			else
-- 				icon = Icons.misc.collapsed
-- 			end
--
-- 			return icon
-- 		end,
-- 	},
-- }
--
-- local sign_column = {
-- 	[[%s]],
-- }
--
-- -- vim.v.wrap
-- local rel_line_number = {
-- 	[[%=%{v:wrap ? "" : v:relnum}]],
-- }
--
-- local line_number = {
-- 	[[%=%{v:wrap ? "" : v:lnum}]],
-- }
-- local spacing = {
-- 	[[ ]],
-- }
--
-- local border = {
-- 	[[%#StatusColumnBorder#]], -- HL
-- 	[[▐]],
-- }
--
-- local padding = {
-- 	[[%#StatusColumnBuffer#]], -- HL
-- 	[[ ]],
-- }
--
-- local function build_statuscolumn(tbl)
-- 	local statuscolumn = {}
--
-- 	for _, value in ipairs(tbl) do
-- 		if type(value) == "string" then
-- 			table.insert(statuscolumn, value)
-- 		elseif type(value) == "table" then
-- 			table.insert(statuscolumn, build_statuscolumn(value))
-- 		end
-- 	end
--
-- 	return table.concat(statuscolumn)
-- end
--
-- local numbertogglegroup = augroup("numbertoggle", { clear = true })
-- autocmd({ "BufEnter", "FocusGained", "InsertLeave" }, {
-- 	pattern = "*",
--
-- 	callback = function()
-- 		vim.opt.statuscolumn =
-- 			build_statuscolumn({ padding, sign_column, rel_line_number, spacing, border, padding })
-- 	end,
-- 	group = numbertogglegroup,
-- })
-- autocmd({ "BufLeave", "FocusLost", "InsertEnter" }, {
-- 	pattern = "*",
-- 	callback = function()
-- 		vim.opt.statuscolumn =
-- 			build_statuscolumn({ padding, sign_column, line_number, spacing, border, padding })
-- 	end,
-- 	group = numbertogglegroup,
-- })

----------------------------------------------------------------------
--                     Also what going on here                      --
----------------------------------------------------------------------

-- if _G.StatusColumn then
-- 	return
-- end
--
-- _G.StatusColumn = {
-- 	handler = {
-- 		fold = function()
-- 			local lnum = vim.fn.getmousepos().line
--
-- 			-- Only lines with a mark should be clickable
-- 			if vim.fn.foldlevel(lnum) <= vim.fn.foldlevel(lnum - 1) then
-- 				return
-- 			end
--
-- 			local state
-- 			if vim.fn.foldclosed(lnum) == -1 then
-- 				state = "close"
-- 			else
-- 				state = "open"
-- 			end
--
-- 			vim.cmd.execute("'" .. lnum .. "fold" .. state .. "'")
-- 		end,
-- 	},
--
-- 	display = {
-- 		line = function()
-- 			if vim.v.wrap then
-- 				return ""
-- 			end
--
-- 			local lnum = tostring(vim.v.lnum)
-- 			if #lnum == 1 then -- Prevent adding a tenth line from bumping the size of the column
-- 				return " " .. lnum
-- 			else
-- 				return lnum
-- 			end
-- 		end,
--
-- 		fold = function()
-- 			if vim.v.wrap then
-- 				return ""
-- 			end
--
-- 			local lnum = vim.v.lnum
-- 			local icon = "  "
--
-- 			-- Line isn't in folding range
-- 			if vim.fn.foldlevel(lnum) <= 0 then
-- 				return icon
-- 			end
--
-- 			-- Not the first line of folding range
-- 			if vim.fn.foldlevel(lnum) <= vim.fn.foldlevel(lnum - 1) then
-- 				return icon
-- 			end
--
-- 			if vim.fn.foldclosed(lnum) == -1 then
-- 				icon = Icons.misc.expanded
-- 			else
-- 				icon = Icons.misc.collapsed
-- 			end
--
-- 			return icon
-- 		end,
-- 	},
--
-- 	sections = {
-- 		sign_column = {
-- 			[[%s]],
-- 		},
-- 		line_number = {
-- 			[[%=%{v:lua.StatusColumn.display.line()}]],
-- 		},
-- 		spacing = {
-- 			[[ ]],
-- 		},
-- 		folds = {
-- 			[[%#FoldColumn#]], -- HL
-- 			[[%@v:lua.StatusColumn.handler.fold@]],
-- 			[[%{v:lua.StatusColumn.display.fold()}]],
-- 		},
-- 		border = {
-- 			[[%#StatusColumnBorder#]], -- HL
-- 			[[▐]],
-- 		},
-- 		padding = {
-- 			[[%#StatusColumnBuffer#]], -- HL
-- 			[[ ]],
-- 		},
-- 	},
--
-- 	build = function(tbl)
-- 		local statuscolumn = {}
--
-- 		for _, value in ipairs(tbl) do
-- 			if type(value) == "string" then
-- 				table.insert(statuscolumn, value)
-- 			elseif type(value) == "table" then
-- 				table.insert(statuscolumn, StatusColumn.build(value))
-- 			end
-- 		end
--
-- 		return table.concat(statuscolumn)
-- 	end,
--
-- 	set_window = function(value)
-- 		vim.defer_fn(function()
-- 			vim.api.nvim_win_set_option(vim.api.nvim_get_current_win(), "statuscolumn", value)
-- 		end, 1)
-- 	end,
-- }
--
-- vim.opt.statuscolumn = StatusColumn.build({
-- 	StatusColumn.sections.sign_column,
-- 	StatusColumn.sections.line_number,
-- 	StatusColumn.sections.spacing,
-- 	StatusColumn.sections.folds,
-- 	StatusColumn.sections.border,
-- 	StatusColumn.sections.padding,
-- })
